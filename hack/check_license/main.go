/*
Copyright 2022-2024 EscherCloud.
Copyright 2024 the Unikorn Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"time"
)

const (

	// apache2LicenseHeader is an exact match for a license header.
	apache2LicenseHeader = `Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.`
)

var (
	// errFail tells you there was an error detected.
	errFail = errors.New("errors detected")

	// errNoComments tells you you've not commented anything, bad engineer.
	errNoComments = errors.New("file contains no comments")

	// errFirstCommentNotLicense tells you that the first comment isn't a license.
	errFirstCommentNotLicense = errors.New("first comment not a valid license")
)

// glob does a recursive walk of the working directory, returning all files that
// match the provided extension e.g. ".go".
func glob(extension string) ([]string, error) {
	var files []string

	appendFileWithExtension := func(path string, f os.FileInfo, err error) error {
		if f.IsDir() {
			return nil
		}

		if filepath.Ext(path) != extension {
			return nil
		}

		files = append(files, path)

		return nil
	}

	wd, err := os.Getwd()
	if err != nil {
		return nil, err
	}

	if err := filepath.Walk(wd, appendFileWithExtension); err != nil {
		return nil, err
	}

	return files, nil
}

//nolint:cyclop
func checkFirstComment(comment *ast.Comment) error {
	if comment.Slash != 1 {
		return fmt.Errorf("%w: first comment starts at %d, expected 1", errFirstCommentNotLicense, comment.Slash)
	}

	if !strings.HasPrefix(comment.Text, "/*") {
		return fmt.Errorf("%w: first comment doesn't start with a C style comment", errFirstCommentNotLicense)
	}

	text := strings.TrimSpace(comment.Text[2 : len(comment.Text)-2])

	if !strings.HasSuffix(text, apache2LicenseHeader) {
		return fmt.Errorf("%w: first comment doesn't end with a license", errFirstCommentNotLicense)
	}

	header := strings.TrimSuffix(text, apache2LicenseHeader)

	headerLines := strings.Split(header, "\n")

	// Expect a copyright, newline, a blank line, newline, nothing!.
	if len(headerLines) < 3 {
		return fmt.Errorf("%w: first comment must have a copyright and space before the license", errFirstCommentNotLicense)
	}

	lastHeaderLineIndex := len(headerLines) - 2

	if headerLines[lastHeaderLineIndex] != "" {
		return fmt.Errorf("%w: first comment doesn't have a space between copyrights and license", errFirstCommentNotLicense)
	}

	copyrights := headerLines[:lastHeaderLineIndex]

	re := regexp.MustCompile(`^Copyright (\d{4})(?:-(\d{4}))? (.*)$`)

	for _, copyright := range copyrights {
		if !re.MatchString(copyright) {
			return fmt.Errorf("%w: copyright not correctly formatted '%s'", errFirstCommentNotLicense, copyright)
		}
	}

	lastCopyright := copyrights[lastHeaderLineIndex-1]

	matches := re.FindStringSubmatch(lastCopyright)

	yearString := matches[1]

	if matches[2] != "" {
		yearString = matches[2]
	}

	year, err := strconv.Atoi(yearString)
	if err != nil {
		return fmt.Errorf("%w: copyright doesn't contain a valid year '%s'", errFirstCommentNotLicense, yearString)
	}

	if year != time.Now().Year() {
		return fmt.Errorf("%w: copyright doesn't contain this year %d", errFirstCommentNotLicense, year)
	}

	if matches[3] != "the Unikorn Authors." {
		return fmt.Errorf("%w: copyright isn't for the right organization '%s'", errFirstCommentNotLicense, matches[3])
	}

	return nil
}

// checkGoLicenseInComments checks the AST for a license header anywhere the top
// level (because autogenerated code does what it likes).
func checkGoLicenseInComments(path string, file *ast.File) error {
	if len(file.Comments) == 0 {
		return fmt.Errorf("%w: %s", errNoComments, path)
	}

	return checkFirstComment(file.Comments[0].List[0])
}

// checkGoLicenseFile parses a source file and checks there is a license header in there.
func checkGoLicenseFile(path string) error {
	fset := token.NewFileSet()

	file, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	if err := checkGoLicenseInComments(path, file); err != nil {
		return err
	}

	return nil
}

// ignoreFile does exhaustive matching of all lines in a file, to find
// an ignore string.
func ignoreFile(path string) (bool, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return false, err
	}

	lines := strings.Split(string(data), "\n")

	ignores := []string{
		"Code generated by",
	}

	for _, line := range lines {
		for _, ignore := range ignores {
			if strings.Contains(line, ignore) {
				return true, nil
			}
		}
	}

	return false, nil
}

// checkGoLicense finds all go source files in the working directory, then parses them
// into an AST and checks there is a license header in there.
func checkGoLicense() error {
	paths, err := glob(".go")
	if err != nil {
		return err
	}

	var hasErrors bool

	for _, path := range paths {
		if ok, err := ignoreFile(path); err != nil {
			fmt.Printf("%s: %s", path, err.Error())

			hasErrors = true
		} else if ok {
			continue
		}

		if err := checkGoLicenseFile(path); err != nil {
			fmt.Printf("%s: %s", path, err.Error())

			hasErrors = true
		}
	}

	if hasErrors {
		return errFail
	}

	return nil
}

// main runs any license checkers over the code.
func main() {
	if err := checkGoLicense(); err != nil {
		fmt.Println(err)

		os.Exit(1)
	}
}
